/* automatically generated by rust-bindgen */

#[doc = " @brief Callback function for mouse events. see cv::setMouseCallback"]
#[doc = "@param event one of the cv::MouseEventTypes constants."]
#[doc = "@param x The x-coordinate of the mouse event."]
#[doc = "@param y The y-coordinate of the mouse event."]
#[doc = "@param flags one of the cv::MouseEventFlags constants."]
#[doc = "@param userdata The optional parameter."]
pub type cv_MouseCallback = u64;
pub const cv_text_classifier_type_OCR_KNN_CLASSIFIER: cv_text_classifier_type = 0;
pub const cv_text_classifier_type_OCR_CNN_CLASSIFIER: cv_text_classifier_type = 1;
pub type cv_text_classifier_type = i32;
#[repr(C)]
pub struct cvsys_Point2i {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cvsys_Point2i() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_Point2i>(),
        8usize,
        concat!("Size of: ", stringify!(cvsys_Point2i))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_Point2i>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_Point2i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Point2i>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_Point2i), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Point2i>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cvsys_Point2i), "::", stringify!(y))
    );
}
#[repr(C)]
pub struct cvsys_Point2f {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_cvsys_Point2f() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_Point2f>(),
        8usize,
        concat!("Size of: ", stringify!(cvsys_Point2f))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_Point2f>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_Point2f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Point2f>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_Point2f), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Point2f>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cvsys_Point2f), "::", stringify!(y))
    );
}
#[repr(C)]
pub struct cvsys_Size2i {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cvsys_Size2i() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_Size2i>(),
        8usize,
        concat!("Size of: ", stringify!(cvsys_Size2i))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_Size2i>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_Size2i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Size2i>())).width as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_Size2i), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Size2i>())).height as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cvsys_Size2i), "::", stringify!(height))
    );
}
#[repr(C)]
pub struct cvsys_Size2f {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_cvsys_Size2f() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_Size2f>(),
        8usize,
        concat!("Size of: ", stringify!(cvsys_Size2f))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_Size2f>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_Size2f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Size2f>())).width as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_Size2f), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Size2f>())).height as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cvsys_Size2f), "::", stringify!(height))
    );
}
#[repr(C)]
pub struct cvsys_Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cvsys_Rect() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(cvsys_Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_Rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Rect>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_Rect), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Rect>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cvsys_Rect), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Rect>())).width as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cvsys_Rect), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Rect>())).height as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(cvsys_Rect), "::", stringify!(height))
    );
}
#[repr(C)]
pub struct cvsys_RotatedRect {
    pub center: cvsys_Point2f,
    pub size: cvsys_Size2f,
    pub angle: f32,
}
#[test]
fn bindgen_test_layout_cvsys_RotatedRect() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_RotatedRect>(),
        20usize,
        concat!("Size of: ", stringify!(cvsys_RotatedRect))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_RotatedRect>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_RotatedRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_RotatedRect>())).center as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_RotatedRect),
            "::",
            stringify!(center)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_RotatedRect>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_RotatedRect),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_RotatedRect>())).angle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_RotatedRect),
            "::",
            stringify!(angle)
        )
    );
}
#[repr(C)]
pub struct cvsys_Scalar {
    pub v0: ::std::os::raw::c_int,
    pub v1: ::std::os::raw::c_int,
    pub v2: ::std::os::raw::c_int,
    pub v3: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cvsys_Scalar() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_Scalar>(),
        16usize,
        concat!("Size of: ", stringify!(cvsys_Scalar))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_Scalar>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_Scalar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Scalar>())).v0 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_Scalar), "::", stringify!(v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Scalar>())).v1 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cvsys_Scalar), "::", stringify!(v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Scalar>())).v2 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cvsys_Scalar), "::", stringify!(v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_Scalar>())).v3 as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(cvsys_Scalar), "::", stringify!(v3))
    );
}
#[repr(C)]
pub struct cvsys_KeyPoint {
    pub pt: cvsys_Point2f,
    pub size: f32,
    pub angle: f32,
    pub response: f32,
    pub octave: ::std::os::raw::c_int,
    pub class_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cvsys_KeyPoint() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_KeyPoint>(),
        28usize,
        concat!("Size of: ", stringify!(cvsys_KeyPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_KeyPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_KeyPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_KeyPoint>())).pt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_KeyPoint), "::", stringify!(pt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_KeyPoint>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cvsys_KeyPoint), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_KeyPoint>())).angle as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(cvsys_KeyPoint), "::", stringify!(angle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_KeyPoint>())).response as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_KeyPoint),
            "::",
            stringify!(response)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_KeyPoint>())).octave as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_KeyPoint),
            "::",
            stringify!(octave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_KeyPoint>())).class_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_KeyPoint),
            "::",
            stringify!(class_id)
        )
    );
}
#[repr(C)]
pub struct cvsys_DMatch {
    pub distance: f32,
    pub imgIdx: ::std::os::raw::c_int,
    pub queryIdx: ::std::os::raw::c_int,
    pub trainIdx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cvsys_DMatch() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_DMatch>(),
        16usize,
        concat!("Size of: ", stringify!(cvsys_DMatch))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_DMatch>(),
        4usize,
        concat!("Alignment of ", stringify!(cvsys_DMatch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_DMatch>())).distance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_DMatch),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_DMatch>())).imgIdx as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cvsys_DMatch), "::", stringify!(imgIdx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_DMatch>())).queryIdx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_DMatch),
            "::",
            stringify!(queryIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_DMatch>())).trainIdx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_DMatch),
            "::",
            stringify!(trainIdx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cvsys_CString {
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cvsys_CString() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_CString>(),
        8usize,
        concat!("Size of: ", stringify!(cvsys_CString))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_CString>(),
        8usize,
        concat!("Alignment of ", stringify!(cvsys_CString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_CString>())).value as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cvsys_CString), "::", stringify!(value))
    );
}
extern "C" {
    #[link_name = "\u{1}?is_str@CString@cvsys@@QEBA_NXZ"]
    pub fn cvsys_CString_is_str(this: *const cvsys_CString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?get_str@CString@cvsys@@QEBAPEBDXZ"]
    pub fn cvsys_CString_get_str(this: *const cvsys_CString) -> *const ::std::os::raw::c_char;
}
impl cvsys_CString {
    #[inline]
    pub unsafe fn is_str(&self) -> bool {
        cvsys_CString_is_str(self)
    }
    #[inline]
    pub unsafe fn get_str(&self) -> *const ::std::os::raw::c_char {
        cvsys_CString_get_str(self)
    }
}
#[repr(C)]
pub struct cvsys_Result<T> {
    pub value: T,
    pub error: cvsys_CString,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct cvsys_EmptyResult {
    pub error: cvsys_CString,
}
#[test]
fn bindgen_test_layout_cvsys_EmptyResult() {
    assert_eq!(
        ::std::mem::size_of::<cvsys_EmptyResult>(),
        8usize,
        concat!("Size of: ", stringify!(cvsys_EmptyResult))
    );
    assert_eq!(
        ::std::mem::align_of::<cvsys_EmptyResult>(),
        8usize,
        concat!("Alignment of ", stringify!(cvsys_EmptyResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cvsys_EmptyResult>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cvsys_EmptyResult),
            "::",
            stringify!(error)
        )
    );
}
#[repr(C)]
pub struct cvsys_CVec<T> {
    pub array: *mut T,
    pub size: usize,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub struct cvsys_COption<T> {
    pub hasValue: bool,
    pub value: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
extern "C" {
    #[link_name = "\u{1}?mat_from_file_storage@cvsys@@YAPEAVMat@cv@@PEBD0@Z"]
    pub fn cvsys_mat_from_file_storage(
        path: *const ::std::os::raw::c_char,
        section: *const ::std::os::raw::c_char,
    ) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?mat_new@cvsys@@YAPEAVMat@cv@@XZ"]
    pub fn cvsys_mat_new() -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?mat_new_with_size@cvsys@@YAPEAVMat@cv@@HHH@Z"]
    pub fn cvsys_mat_new_with_size(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?mat_zeros@cvsys@@YAPEAVMat@cv@@HHH@Z"]
    pub fn cvsys_mat_zeros(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?mat_from_buffer@cvsys@@YAPEAVMat@cv@@HHHPEBE@Z"]
    pub fn cvsys_mat_from_buffer(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        buf: *const u8,
    ) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?mat_eye@cvsys@@YAPEAVMat@cv@@HHH@Z"]
    pub fn cvsys_mat_eye(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?mat_valid@cvsys@@YA_NPEAVMat@cv@@@Z"]
    pub fn cvsys_mat_valid(mat: *mut cv_Mat) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?mat_roi@cvsys@@YAPEAVMat@cv@@PEAV23@URect@1@@Z"]
    pub fn cvsys_mat_roi(mat: *mut cv_Mat, crect: cvsys_Rect) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?mat_flip@cvsys@@YAXPEAVMat@cv@@H@Z"]
    pub fn cvsys_mat_flip(image: *mut cv_Mat, code: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?mat_rows@cvsys@@YAHQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_rows(mat: *const cv_Mat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?mat_cols@cvsys@@YAHQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_cols(mat: *const cv_Mat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?mat_depth@cvsys@@YAHQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_depth(mat: *const cv_Mat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?mat_channels@cvsys@@YAHQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_channels(mat: *const cv_Mat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?mat_type@cvsys@@YAHQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_type(mat: *const cv_Mat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?mat_data@cvsys@@YAPEBEQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_data(mat: *const cv_Mat) -> *const u8;
}
extern "C" {
    #[link_name = "\u{1}?mat_total@cvsys@@YA_KQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_total(mat: *const cv_Mat) -> usize;
}
extern "C" {
    #[link_name = "\u{1}?mat_elem_size@cvsys@@YA_KQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_elem_size(mat: *const cv_Mat) -> usize;
}
extern "C" {
    #[link_name = "\u{1}?mat_elem_size1@cvsys@@YA_KQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_elem_size1(mat: *const cv_Mat) -> usize;
}
extern "C" {
    #[link_name = "\u{1}?mat_step1@cvsys@@YA_KQEBVMat@cv@@H@Z"]
    pub fn cvsys_mat_step1(mat: *const cv_Mat, i: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[link_name = "\u{1}?mat_drop@cvsys@@YAXPEAVMat@cv@@@Z"]
    pub fn cvsys_mat_drop(mat: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?mat_in_range@cvsys@@YAXPEAVMat@cv@@UScalar@1@10@Z"]
    pub fn cvsys_mat_in_range(mat: *mut cv_Mat, lowerb: cvsys_Scalar, upperb: cvsys_Scalar, dst: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?mat_min_max_loc@cvsys@@YAXQEBVMat@cv@@PEAN1PEAUPoint2i@1@20@Z"]
    pub fn cvsys_mat_min_max_loc(
        mat: *const cv_Mat,
        min: *mut f64,
        max: *mut f64,
        minLoc: *mut cvsys_Point2i,
        maxLoc: *mut cvsys_Point2i,
        cmask: *const cv_Mat,
    );
}
extern "C" {
    #[link_name = "\u{1}?mat_mix_channels@cvsys@@YAXPEAVMat@cv@@_K01PEBH1@Z"]
    pub fn cvsys_mat_mix_channels(
        mat: *mut cv_Mat,
        nsrcs: usize,
        dst: *mut cv_Mat,
        ndsts: usize,
        from_to: *const ::std::os::raw::c_int,
        npairs: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}?mat_normalize@cvsys@@YAXPEAVMat@cv@@0NNH@Z"]
    pub fn cvsys_mat_normalize(
        csrc: *mut cv_Mat,
        cdst: *mut cv_Mat,
        alpha: f64,
        beta: f64,
        norm_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?mat_bitwise_and@cvsys@@YAXQEBVMat@cv@@0PEAV23@@Z"]
    pub fn cvsys_mat_bitwise_and(src1: *const cv_Mat, src2: *const cv_Mat, dst: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?mat_bitwise_not@cvsys@@YAXQEBVMat@cv@@QEAV23@@Z"]
    pub fn cvsys_mat_bitwise_not(src: *const cv_Mat, dst: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?mat_bitwise_or@cvsys@@YAXQEBVMat@cv@@0PEAV23@@Z"]
    pub fn cvsys_mat_bitwise_or(src1: *const cv_Mat, src2: *const cv_Mat, dst: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?mat_bitwise_xor@cvsys@@YAXQEBVMat@cv@@0PEAV23@@Z"]
    pub fn cvsys_mat_bitwise_xor(src1: *const cv_Mat, src2: *const cv_Mat, dst: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?mat_count_non_zero@cvsys@@YAHQEBVMat@cv@@@Z"]
    pub fn cvsys_mat_count_non_zero(src: *const cv_Mat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?mat_copy_make_border@cvsys@@YAXQEBVMat@cv@@QEAV23@HHHHHUScalar@1@@Z"]
    pub fn cvsys_mat_copy_make_border(
        src1: *const cv_Mat,
        dst: *mut cv_Mat,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
        value: cvsys_Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?mser_new@cvsys@@YAPEAU?$Ptr@VMSER@cv@@@cv@@HHHNNHNNH@Z"]
    pub fn cvsys_mser_new(
        delta: ::std::os::raw::c_int,
        min_area: ::std::os::raw::c_int,
        max_area: ::std::os::raw::c_int,
        max_variation: f64,
        min_diversity: f64,
        max_evolution: ::std::os::raw::c_int,
        area_threshold: f64,
        min_margin: f64,
        edge_blur_size: ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}?mser_drop@cvsys@@YAXPEAU?$Ptr@VMSER@cv@@@cv@@@Z"]
    pub fn cvsys_mser_drop(detector: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?mser_detect_regions@cvsys@@YAXPEAU?$Ptr@VMSER@cv@@@cv@@PEAVMat@3@PEAU?$CVec@U?$CVec@UPoint2i@cvsys@@@cvsys@@@1@PEAU?$CVec@URect@cvsys@@@1@@Z"]
    pub fn cvsys_mser_detect_regions(
        detector: *mut u8,
        image: *mut cv_Mat,
        msers: *mut cvsys_CVec<cvsys_CVec<cvsys_Point2i>>,
        bboxes: *mut cvsys_CVec<cvsys_Rect>,
    );
}
extern "C" {
    #[link_name = "\u{1}?mser_detect_and_compute@cvsys@@YAXPEAU?$Ptr@VMSER@cv@@@cv@@PEAVMat@3@1PEAU?$CVec@UKeyPoint@cvsys@@@1@1_N@Z"]
    pub fn cvsys_mser_detect_and_compute(
        detector: *mut u8,
        image: *mut cv_Mat,
        mask: *mut cv_Mat,
        keypoints: *mut cvsys_CVec<cvsys_KeyPoint>,
        descriptors: *mut cv_Mat,
        useProvidedKeypoints: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?matcher_new@cvsys@@YAPEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@PEBD@Z"]
    pub fn cvsys_matcher_new(descriptorMatcherType: *const ::std::os::raw::c_char) -> *mut [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}?matcher_drop@cvsys@@YAXPEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@@Z"]
    pub fn cvsys_matcher_drop(descriptorMatcher: *mut [u64; 2usize]);
}
extern "C" {
    #[link_name = "\u{1}?matcher_add@cvsys@@YAXAEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@PEBQEAVMat@3@_K@Z"]
    pub fn cvsys_matcher_add(descriptorMatcher: *mut [u64; 2usize], descriptors: *const *mut cv_Mat, len: usize);
}
extern "C" {
    #[link_name = "\u{1}?matcher_train@cvsys@@YAXAEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@@Z"]
    pub fn cvsys_matcher_train(descriptorMatcher: *mut [u64; 2usize]);
}
extern "C" {
    #[link_name = "\u{1}?matcher_is_empty@cvsys@@YA_NAEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@@Z"]
    pub fn cvsys_matcher_is_empty(descriptorMatcher: *mut [u64; 2usize]) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?matcher_match@cvsys@@YAXAEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@AEAVMat@3@PEAU?$CVec@UDMatch@cvsys@@@1@@Z"]
    pub fn cvsys_matcher_match(
        descriptorMatcher: *mut [u64; 2usize],
        queryDescriptors: *mut cv_Mat,
        matches: *mut cvsys_CVec<cvsys_DMatch>,
    );
}
extern "C" {
    #[link_name = "\u{1}?matcher_match_two@cvsys@@YAXAEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@AEAVMat@3@1PEAU?$CVec@UDMatch@cvsys@@@1@@Z"]
    pub fn cvsys_matcher_match_two(
        descriptorMatcher: *mut [u64; 2usize],
        queryDescriptors: *mut cv_Mat,
        trainDescriptors: *mut cv_Mat,
        matches: *mut cvsys_CVec<cvsys_DMatch>,
    );
}
extern "C" {
    #[link_name = "\u{1}?matcher_knn_match@cvsys@@YAXAEAU?$Ptr@VDescriptorMatcher@cv@@@cv@@AEAVMat@3@HPEAU?$CVec@U?$CVec@UDMatch@cvsys@@@cvsys@@@1@@Z"]
    pub fn cvsys_matcher_knn_match(
        descriptorMatcher: *mut [u64; 2usize],
        queryDescriptors: *mut cv_Mat,
        k: ::std::os::raw::c_int,
        matches: *mut cvsys_CVec<cvsys_CVec<cvsys_DMatch>>,
    );
}
extern "C" {
    #[link_name = "\u{1}?bow_trainer_new@cvsys@@YAPEAVBOWKMeansTrainer@cv@@HAEBVTermCriteria@3@HH@Z"]
    pub fn cvsys_bow_trainer_new(
        clusterCount: ::std::os::raw::c_int,
        termcrit: *const cv_TermCriteria,
        attempts: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> *mut cv_BOWKMeansTrainer;
}
extern "C" {
    #[link_name = "\u{1}?bow_trainer_drop@cvsys@@YAXPEAVBOWKMeansTrainer@cv@@@Z"]
    pub fn cvsys_bow_trainer_drop(trainer: *mut cv_BOWKMeansTrainer);
}
extern "C" {
    #[link_name = "\u{1}?bow_trainer_add@cvsys@@YAXAEAVBOWKMeansTrainer@cv@@AEAVMat@3@@Z"]
    pub fn cvsys_bow_trainer_add(trainer: *mut cv_BOWKMeansTrainer, descriptors: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?bow_trainer_cluster@cvsys@@YAPEAVMat@cv@@AEAVBOWKMeansTrainer@3@@Z"]
    pub fn cvsys_bow_trainer_cluster(trainer: *mut cv_BOWKMeansTrainer) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?nat_named_window@cvsys@@YAXQEBDH@Z"]
    pub fn cvsys_nat_named_window(winname: *const ::std::os::raw::c_char, flags: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?nat_destroy_window@cvsys@@YAXQEBD@Z"]
    pub fn cvsys_nat_destroy_window(winname: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?nat_set_mouse_callback@cvsys@@YAXQEBDP6AXHHHHPEAX@Z1@Z"]
    pub fn cvsys_nat_set_mouse_callback(
        winname: *const ::std::os::raw::c_char,
        on_mouse: ::std::option::Option<
            unsafe extern "C" fn(
                winname: ::std::os::raw::c_int,
                on_mouse: ::std::os::raw::c_int,
                userdata: ::std::os::raw::c_int,
                arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}?nat_imshow@cvsys@@YAXQEBDPEAVMat@cv@@@Z"]
    pub fn cvsys_nat_imshow(winname: *const ::std::os::raw::c_char, mat: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?nat_wait_key@cvsys@@YAHH@Z"]
    pub fn cvsys_nat_wait_key(delay_in_millis: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?to_ffi@cvsys@@YAXAEBV?$Rect_@H@cv@@PEAURect@1@@Z"]
    pub fn cvsys_to_ffi(source: *const cv_Rect, dest: *mut cvsys_Rect);
}
extern "C" {
    #[link_name = "\u{1}?to_ffi@cvsys@@YAXAEBV?$Point_@H@cv@@PEAUPoint2i@1@@Z"]
    pub fn cvsys_to_ffi1(source: *const cv_Point, dest: *mut cvsys_Point2i);
}
extern "C" {
    #[link_name = "\u{1}?to_ffi@cvsys@@YAXAEBVKeyPoint@cv@@PEAU21@@Z"]
    pub fn cvsys_to_ffi2(source: *const cv_KeyPoint, dest: *mut cvsys_KeyPoint);
}
extern "C" {
    #[link_name = "\u{1}?to_ffi@cvsys@@YAXAEBVDMatch@cv@@PEAU21@@Z"]
    pub fn cvsys_to_ffi3(source: *const cv_DMatch, dest: *mut cvsys_DMatch);
}
extern "C" {
    #[link_name = "\u{1}?to_ffi@cvsys@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUCString@1@@Z"]
    pub fn cvsys_to_ffi4(source: *const std_string, dest: *mut cvsys_CString);
}
extern "C" {
    #[link_name = "\u{1}?ffi_to_cv@cvsys@@YAXAEBVMat@cv@@PEAV23@@Z"]
    pub fn cvsys_ffi_to_cv(source: *const cv_Mat, dest: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?nat_imread@cvsys@@YAPEAVMat@cv@@QEBDH@Z"]
    pub fn cvsys_nat_imread(filename: *const ::std::os::raw::c_char, flags: ::std::os::raw::c_int) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?nat_imdecode@cvsys@@YAPEAVMat@cv@@QEBE_KH@Z"]
    pub fn cvsys_nat_imdecode(buffer: *const u8, len: usize, flag: ::std::os::raw::c_int) -> *mut cv_Mat;
}
extern "C" {
    #[link_name = "\u{1}?nat_imencode@cvsys@@YAXQEBDQEBVMat@cv@@QEBH_KPEAU?$COption@U?$CVec@E@cvsys@@@1@@Z"]
    pub fn cvsys_nat_imencode(
        ext: *const ::std::os::raw::c_char,
        image: *const cv_Mat,
        flag_ptr: *const ::std::os::raw::c_int,
        flag_size: usize,
        result: *mut cvsys_COption<cvsys_CVec<u8>>,
    );
}
extern "C" {
    #[link_name = "\u{1}?nat_line@cvsys@@YAXPEAVMat@cv@@UPoint2i@1@1UScalar@1@HHH@Z"]
    pub fn cvsys_nat_line(
        mat: *mut cv_Mat,
        pt1: cvsys_Point2i,
        pt2: cvsys_Point2i,
        color: cvsys_Scalar,
        thickness: ::std::os::raw::c_int,
        linetype: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?nat_rectangle@cvsys@@YAXPEAVMat@cv@@URect@1@UScalar@1@HH@Z"]
    pub fn cvsys_nat_rectangle(
        mat: *mut cv_Mat,
        crect: cvsys_Rect,
        color: cvsys_Scalar,
        thickness: ::std::os::raw::c_int,
        linetype: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?nat_ellipse@cvsys@@YAXPEAVMat@cv@@UPoint2i@1@USize2i@1@NNNUScalar@1@HHH@Z"]
    pub fn cvsys_nat_ellipse(
        mat: *mut cv_Mat,
        center: cvsys_Point2i,
        axes: cvsys_Size2i,
        angle: f64,
        start_angle: f64,
        end_angle: f64,
        color: cvsys_Scalar,
        thickness: ::std::os::raw::c_int,
        linetype: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?cvt_color@cvsys@@YAXPEAVMat@cv@@0H@Z"]
    pub fn cvsys_cvt_color(mat: *mut cv_Mat, output: *mut cv_Mat, code: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}?pyr_down@cvsys@@YAXPEAVMat@cv@@0@Z"]
    pub fn cvsys_pyr_down(mat: *mut cv_Mat, output: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?nat_threshold@cvsys@@YAXPEAVMat@cv@@0NNH@Z"]
    pub fn cvsys_nat_threshold(
        mat: *mut cv_Mat,
        out: *mut cv_Mat,
        thresh: f64,
        maxval: f64,
        ttype: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?nat_erode@cvsys@@YAXPEAVMat@cv@@00UPoint2i@1@HHUScalar@1@@Z"]
    pub fn cvsys_nat_erode(
        mat: *mut cv_Mat,
        out: *mut cv_Mat,
        kernel: *mut cv_Mat,
        anchor: cvsys_Point2i,
        iterations: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
        borderValue: cvsys_Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?nat_dilate@cvsys@@YAXPEAVMat@cv@@00UPoint2i@1@HHUScalar@1@@Z"]
    pub fn cvsys_nat_dilate(
        mat: *mut cv_Mat,
        out: *mut cv_Mat,
        kernel: *mut cv_Mat,
        anchor: cvsys_Point2i,
        iterations: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
        borderValue: cvsys_Scalar,
    );
}
extern "C" {
    #[link_name = "\u{1}?gaussian_blur@cvsys@@YAXPEAVMat@cv@@0USize2i@1@NNH@Z"]
    pub fn cvsys_gaussian_blur(
        mat: *mut cv_Mat,
        out: *mut cv_Mat,
        ksize: cvsys_Size2i,
        sigmaX: f64,
        sigmaY: f64,
        bordertype: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?nat_resize@cvsys@@YAXPEAVMat@cv@@0USize2i@1@NNH@Z"]
    pub fn cvsys_nat_resize(
        from: *mut cv_Mat,
        to: *mut cv_Mat,
        dsize: cvsys_Size2i,
        fx: f64,
        fy: f64,
        interpolation: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?calc_hist@cvsys@@YAXQEBVMat@cv@@HPEBHPEAV23@2H1PEBQEBM@Z"]
    pub fn cvsys_calc_hist(
        cimages: *const cv_Mat,
        nimages: ::std::os::raw::c_int,
        channels: *const ::std::os::raw::c_int,
        mask: *mut cv_Mat,
        hist: *mut cv_Mat,
        dims: ::std::os::raw::c_int,
        hist_size: *const ::std::os::raw::c_int,
        ranges: *const *const f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?calc_back_project@cvsys@@YAXPEBVMat@cv@@HPEBHPEAV23@2PEBQEBM@Z"]
    pub fn cvsys_calc_back_project(
        images: *const cv_Mat,
        nimages: ::std::os::raw::c_int,
        channels: *const ::std::os::raw::c_int,
        hist: *mut cv_Mat,
        back_project: *mut cv_Mat,
        ranges: *const *const f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?compare_hist@cvsys@@YAXPEAVMat@cv@@0HPEAU?$Result@N@1@@Z"]
    pub fn cvsys_compare_hist(
        first_image: *mut cv_Mat,
        second_image: *mut cv_Mat,
        method: ::std::os::raw::c_int,
        result: *mut cvsys_Result<f64>,
    );
}
extern "C" {
    #[link_name = "\u{1}?sobel@cvsys@@YAXPEAVMat@cv@@0HHHHNNH@Z"]
    pub fn cvsys_sobel(
        src: *mut cv_Mat,
        dst: *mut cv_Mat,
        ddepth: ::std::os::raw::c_int,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        k_size: ::std::os::raw::c_int,
        scale: f64,
        delta: f64,
        borderType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?scharr@cvsys@@YAXPEAVMat@cv@@0HHHNNH@Z"]
    pub fn cvsys_scharr(
        src: *mut cv_Mat,
        dst: *mut cv_Mat,
        ddepth: ::std::os::raw::c_int,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        scale: f64,
        delta: f64,
        borderType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?canny@cvsys@@YA?AUEmptyResult@1@PEAVMat@cv@@0NNH_N@Z"]
    pub fn cvsys_canny(
        image: *mut cv_Mat,
        edges: *mut cv_Mat,
        threshold1: f64,
        threshold2: f64,
        aperture_size: ::std::os::raw::c_int,
        l2_gradient: bool,
    ) -> cvsys_EmptyResult;
}
extern "C" {
    #[link_name = "\u{1}?cascade_classifier_new@cvsys@@YAPEAVCascadeClassifier@cv@@XZ"]
    pub fn cvsys_cascade_classifier_new() -> *mut cv_CascadeClassifier;
}
extern "C" {
    #[link_name = "\u{1}?cascade_classifier_from_path@cvsys@@YAPEAVCascadeClassifier@cv@@QEBD@Z"]
    pub fn cvsys_cascade_classifier_from_path(path: *const ::std::os::raw::c_char) -> *mut cv_CascadeClassifier;
}
extern "C" {
    #[link_name = "\u{1}?cascade_classifier_load@cvsys@@YA_NPEAVCascadeClassifier@cv@@QEBD@Z"]
    pub fn cvsys_cascade_classifier_load(cc: *mut cv_CascadeClassifier, path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?cascade_classifier_drop@cvsys@@YAXPEAVCascadeClassifier@cv@@@Z"]
    pub fn cvsys_cascade_classifier_drop(cc: *mut cv_CascadeClassifier);
}
extern "C" {
    #[link_name = "\u{1}?cascade_classifier_detect@cvsys@@YAXPEAVCascadeClassifier@cv@@PEAVMat@3@PEAU?$CVec@URect@cvsys@@@1@NHHUSize2i@1@3@Z"]
    pub fn cvsys_cascade_classifier_detect(
        cascade: *mut cv_CascadeClassifier,
        mat: *mut cv_Mat,
        vec_of_rect: *mut cvsys_CVec<cvsys_Rect>,
        scale_factor: f64,
        min_neighbors: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        min_size: cvsys_Size2i,
        max_size: cvsys_Size2i,
    );
}
extern "C" {
    #[link_name = "\u{1}?hog_new@cvsys@@YAPEAUHOGDescriptor@cv@@XZ"]
    pub fn cvsys_hog_new() -> *mut cv_HOGDescriptor;
}
extern "C" {
    #[link_name = "\u{1}?hog_drop@cvsys@@YAXPEAUHOGDescriptor@cv@@@Z"]
    pub fn cvsys_hog_drop(arg1: *mut cv_HOGDescriptor);
}
extern "C" {
    #[link_name = "\u{1}?hog_default_people_detector@cvsys@@YAPEAXXZ"]
    pub fn cvsys_hog_default_people_detector() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?hog_daimler_people_detector@cvsys@@YAPEAXXZ"]
    pub fn cvsys_hog_daimler_people_detector() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?hog_detector_drop@cvsys@@YAXPEAX@Z"]
    pub fn cvsys_hog_detector_drop(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?hog_set_svm_detector@cvsys@@YAXPEAUHOGDescriptor@cv@@PEAX@Z"]
    pub fn cvsys_hog_set_svm_detector(arg1: *mut cv_HOGDescriptor, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?hog_detect@cvsys@@YAXPEAUHOGDescriptor@cv@@PEAVMat@3@PEAU?$CVec@URect@cvsys@@@1@PEAU?$CVec@N@1@USize2i@1@4NN_N@Z"]
    pub fn cvsys_hog_detect(
        arg1: *mut cv_HOGDescriptor,
        arg2: *mut cv_Mat,
        vec_detected: *mut cvsys_CVec<cvsys_Rect>,
        vec_weight: *mut cvsys_CVec<f64>,
        win_stride: cvsys_Size2i,
        padding: cvsys_Size2i,
        scale: f64,
        final_threshold: f64,
        use_means_shift: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?videocapture_new@cvsys@@YAPEAVVideoCapture@cv@@H@Z"]
    pub fn cvsys_videocapture_new(index: ::std::os::raw::c_int) -> *mut cv_VideoCapture;
}
extern "C" {
    #[link_name = "\u{1}?videocapture_from_file@cvsys@@YAPEAVVideoCapture@cv@@QEBD@Z"]
    pub fn cvsys_videocapture_from_file(filename: *const ::std::os::raw::c_char) -> *mut cv_VideoCapture;
}
extern "C" {
    #[link_name = "\u{1}?videocapture_from_gst_pipeline@cvsys@@YAPEAVVideoCapture@cv@@QEBD@Z"]
    pub fn cvsys_videocapture_from_gst_pipeline(pipeline: *const ::std::os::raw::c_char) -> *mut cv_VideoCapture;
}
extern "C" {
    #[link_name = "\u{1}?videocapture_is_opened@cvsys@@YA_NQEBVVideoCapture@cv@@@Z"]
    pub fn cvsys_videocapture_is_opened(cap: *const cv_VideoCapture) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?videocapture_read@cvsys@@YA_NPEAVVideoCapture@cv@@PEAVMat@3@@Z"]
    pub fn cvsys_videocapture_read(cap: *mut cv_VideoCapture, mat: *mut cv_Mat) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?videocapture_drop@cvsys@@YAXPEAVVideoCapture@cv@@@Z"]
    pub fn cvsys_videocapture_drop(cap: *mut cv_VideoCapture);
}
extern "C" {
    #[link_name = "\u{1}?videocapture_set@cvsys@@YA_NPEAVVideoCapture@cv@@HN@Z"]
    pub fn cvsys_videocapture_set(cap: *mut cv_VideoCapture, property: ::std::os::raw::c_int, value: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?videocapture_get@cvsys@@YANPEAVVideoCapture@cv@@H@Z"]
    pub fn cvsys_videocapture_get(cap: *mut cv_VideoCapture, property: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?videowriter_default@cvsys@@YAPEAVVideoWriter@cv@@XZ"]
    pub fn cvsys_videowriter_default() -> *mut cv_VideoWriter;
}
extern "C" {
    #[link_name = "\u{1}?videowriter_new@cvsys@@YAPEAVVideoWriter@cv@@QEBDHNUSize2i@1@_N@Z"]
    pub fn cvsys_videowriter_new(
        path: *const ::std::os::raw::c_char,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frame_size: cvsys_Size2i,
        is_color: bool,
    ) -> *mut cv_VideoWriter;
}
extern "C" {
    #[link_name = "\u{1}?videowriter_drop@cvsys@@YAXPEAVVideoWriter@cv@@@Z"]
    pub fn cvsys_videowriter_drop(writer: *mut cv_VideoWriter);
}
extern "C" {
    #[link_name = "\u{1}?videowriter_open@cvsys@@YA_NPEAVVideoWriter@cv@@QEBDHNUSize2i@1@_N@Z"]
    pub fn cvsys_videowriter_open(
        writer: *mut cv_VideoWriter,
        path: *const ::std::os::raw::c_char,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frame_size: cvsys_Size2i,
        is_color: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?videowriter_is_opened@cvsys@@YA_NPEAVVideoWriter@cv@@@Z"]
    pub fn cvsys_videowriter_is_opened(writer: *mut cv_VideoWriter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?videowriter_write@cvsys@@YAXPEAVVideoWriter@cv@@PEAVMat@3@@Z"]
    pub fn cvsys_videowriter_write(writer: *mut cv_VideoWriter, mat: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?videowriter_set@cvsys@@YA_NPEAVVideoWriter@cv@@HN@Z"]
    pub fn cvsys_videowriter_set(writer: *mut cv_VideoWriter, property: ::std::os::raw::c_int, value: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?videowriter_get@cvsys@@YANPEAVVideoWriter@cv@@H@Z"]
    pub fn cvsys_videowriter_get(writer: *mut cv_VideoWriter, property: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?term_criteria_new@cvsys@@YAPEAVTermCriteria@cv@@HHN@Z"]
    pub fn cvsys_term_criteria_new(
        type_: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        epsilon: f64,
    ) -> *mut cv_TermCriteria;
}
extern "C" {
    #[link_name = "\u{1}?term_criteria_drop@cvsys@@YAXPEAVTermCriteria@cv@@@Z"]
    pub fn cvsys_term_criteria_drop(criteria: *mut cv_TermCriteria);
}
extern "C" {
    #[link_name = "\u{1}?camshift@cvsys@@YA?AURotatedRect@1@PEAVMat@cv@@URect@1@PEAVTermCriteria@4@@Z"]
    pub fn cvsys_camshift(
        back_project_image: *mut cv_Mat,
        window: cvsys_Rect,
        criteria: *mut cv_TermCriteria,
    ) -> cvsys_RotatedRect;
}
extern "C" {
    #[link_name = "\u{1}?surf_new@cvsys@@YAPEAXNHH_N0@Z"]
    pub fn cvsys_surf_new(
        hessianThreshold: f64,
        nOctaves: ::std::os::raw::c_int,
        nOctaveLayers: ::std::os::raw::c_int,
        extended: bool,
        upright: bool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?surf_drop@cvsys@@YAXPEAX@Z"]
    pub fn cvsys_surf_drop(detector: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?surf_detect_and_compute@cvsys@@YAXPEAXPEAVMat@cv@@1PEAU?$CVec@UKeyPoint@cvsys@@@1@1_N@Z"]
    pub fn cvsys_surf_detect_and_compute(
        detector: *mut ::std::os::raw::c_void,
        image: *mut cv_Mat,
        mask: *mut cv_Mat,
        keypoints: *mut cvsys_CVec<cvsys_KeyPoint>,
        descriptors: *mut cv_Mat,
        useProvidedKeypoints: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?sift_new@cvsys@@YAPEAXHHNNN@Z"]
    pub fn cvsys_sift_new(
        nfeatures: ::std::os::raw::c_int,
        nOctaveLayers: ::std::os::raw::c_int,
        contrastThreshold: f64,
        edgeThreshold: f64,
        sigma: f64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}?sift_drop@cvsys@@YAXPEAX@Z"]
    pub fn cvsys_sift_drop(detector: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}?sift_detect_and_compute@cvsys@@YAXPEAXPEAVMat@cv@@1PEAU?$CVec@UKeyPoint@cvsys@@@1@1_N@Z"]
    pub fn cvsys_sift_detect_and_compute(
        detector: *mut ::std::os::raw::c_void,
        image: *mut cv_Mat,
        mask: *mut cv_Mat,
        keypoints: *mut cvsys_CVec<cvsys_KeyPoint>,
        descriptors: *mut cv_Mat,
        useProvidedKeypoints: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}?hash_any_compute@cvsys@@YAXPEAXAEAVMat@cv@@1@Z"]
    pub fn cvsys_hash_any_compute(phash: *mut ::std::os::raw::c_void, mat: *mut cv_Mat, result: *mut cv_Mat);
}
extern "C" {
    #[link_name = "\u{1}?hash_any_compare@cvsys@@YANPEAXAEAVMat@cv@@1@Z"]
    pub fn cvsys_hash_any_compare(phash: *mut ::std::os::raw::c_void, lhs: *mut cv_Mat, rhs: *mut cv_Mat) -> f64;
}
extern "C" {
    #[link_name = "\u{1}?average_hash_new@cvsys@@YAPEAU?$Ptr@VAverageHash@img_hash@cv@@@cv@@XZ"]
    pub fn cvsys_average_hash_new() -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}?average_hash_drop@cvsys@@YAXPEAU?$Ptr@VAverageHash@img_hash@cv@@@cv@@@Z"]
    pub fn cvsys_average_hash_drop(phash: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?block_mean_hash_new@cvsys@@YAPEAU?$Ptr@VBlockMeanHash@img_hash@cv@@@cv@@XZ"]
    pub fn cvsys_block_mean_hash_new() -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}?block_mean_hash_drop@cvsys@@YAXPEAU?$Ptr@VBlockMeanHash@img_hash@cv@@@cv@@@Z"]
    pub fn cvsys_block_mean_hash_drop(phash: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?color_moment_hash_new@cvsys@@YAPEAU?$Ptr@VColorMomentHash@img_hash@cv@@@cv@@XZ"]
    pub fn cvsys_color_moment_hash_new() -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}?color_moment_hash_drop@cvsys@@YAXPEAU?$Ptr@VColorMomentHash@img_hash@cv@@@cv@@@Z"]
    pub fn cvsys_color_moment_hash_drop(phash: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?marr_hildreth_hash_new@cvsys@@YAPEAU?$Ptr@VMarrHildrethHash@img_hash@cv@@@cv@@XZ"]
    pub fn cvsys_marr_hildreth_hash_new() -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}?marr_hildreth_hash_drop@cvsys@@YAXPEAU?$Ptr@VMarrHildrethHash@img_hash@cv@@@cv@@@Z"]
    pub fn cvsys_marr_hildreth_hash_drop(phash: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?phash_new@cvsys@@YAPEAU?$Ptr@VPHash@img_hash@cv@@@cv@@XZ"]
    pub fn cvsys_phash_new() -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}?phash_drop@cvsys@@YAXPEAU?$Ptr@VPHash@img_hash@cv@@@cv@@@Z"]
    pub fn cvsys_phash_drop(phash: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?radial_variance_hash_new@cvsys@@YAPEAU?$Ptr@VRadialVarianceHash@img_hash@cv@@@cv@@XZ"]
    pub fn cvsys_radial_variance_hash_new() -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}?radial_variance_hash_drop@cvsys@@YAXPEAU?$Ptr@VRadialVarianceHash@img_hash@cv@@@cv@@@Z"]
    pub fn cvsys_radial_variance_hash_drop(phash: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?ocr_run@cvsys@@YAXAEAU?$Ptr@VBaseOCR@text@cv@@@cv@@AEAVMat@3@PEAUCString@1@PEAU?$CVec@URect@cvsys@@@1@PEAU?$CVec@UCString@cvsys@@@1@PEAU?$CVec@M@1@H@Z"]
    pub fn cvsys_ocr_run(
        ocr: *mut u8,
        image: *mut cv_Mat,
        output_text: *mut cvsys_CString,
        component_rects: *mut cvsys_CVec<cvsys_Rect>,
        component_texts: *mut cvsys_CVec<cvsys_CString>,
        component_confidences: *mut cvsys_CVec<f32>,
        component_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}?tesseract_new@cvsys@@YAXPEBD00HHPEAU?$Result@PEAX@1@@Z"]
    pub fn cvsys_tesseract_new(
        datapath: *const ::std::os::raw::c_char,
        language: *const ::std::os::raw::c_char,
        char_whitelist: *const ::std::os::raw::c_char,
        oem: ::std::os::raw::c_int,
        psmode: ::std::os::raw::c_int,
        result: *mut cvsys_Result<*mut ::std::os::raw::c_void>,
    );
}
extern "C" {
    #[link_name = "\u{1}?tesseract_drop@cvsys@@YAXPEAU?$Ptr@VOCRTesseract@text@cv@@@cv@@@Z"]
    pub fn cvsys_tesseract_drop(ocr: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?hmm_new@cvsys@@YAXPEBD0AEAVMat@cv@@1W4classifier_type@text@3@PEAU?$Result@PEAX@1@@Z"]
    pub fn cvsys_hmm_new(
        classifier_filename: *const ::std::os::raw::c_char,
        vocabulary: *const ::std::os::raw::c_char,
        transition_probabilities_table: *mut cv_Mat,
        emission_probabilities_table: *mut cv_Mat,
        classifier_type: cv_text_classifier_type,
        result: *mut cvsys_Result<*mut ::std::os::raw::c_void>,
    );
}
extern "C" {
    #[link_name = "\u{1}?hmm_drop@cvsys@@YAXPEAU?$Ptr@VOCRHMMDecoder@text@cv@@@cv@@@Z"]
    pub fn cvsys_hmm_drop(ocr: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?holistic_new@cvsys@@YAXPEBD00PEAU?$Result@PEAX@1@@Z"]
    pub fn cvsys_holistic_new(
        archive_file: *const ::std::os::raw::c_char,
        weights_file: *const ::std::os::raw::c_char,
        words_file: *const ::std::os::raw::c_char,
        result: *mut cvsys_Result<*mut ::std::os::raw::c_void>,
    );
}
extern "C" {
    #[link_name = "\u{1}?holistic_drop@cvsys@@YAXPEAU?$Ptr@VOCRHolisticWordRecognizer@text@cv@@@cv@@@Z"]
    pub fn cvsys_holistic_drop(ocr: *mut u8);
}
